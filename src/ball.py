# # src/ball.py
# """
# Ï∂ïÍµ¨Í≥µÏùò ÌÉêÏßÄ, Ï∂îÏ†Å, ÏÉÅÌÉú ÏòàÏ∏°ÏùÑ Îã¥ÎãπÌïòÎäî Î™®Îìà (ver. 3)
# - 'POST_IMPACT_TRACKING' ÏÉÅÌÉú Ï∂îÍ∞Ä
# - analyzer.pyÎ°úÎ∂ÄÌÑ∞ Ïã†Ìò∏Î•º Î∞õÏïÑ Î¨ºÎ¶¨ Î™®Îç∏(Ï§ëÎ†•) Î∞è ÌååÎùºÎØ∏ÌÑ∞ Î≥ÄÍ≤Ω Í∏∞Îä• Ï∂îÍ∞Ä
# """
# import numpy as np
# from ultralytics import YOLO
# from typing import Dict, Any, Optional, List
# import mediapipe as mp

# # ÎÇ¥Î∂Ä Î™®Îìà ÏûÑÌè¨Ìä∏
# from . import config
# from .utils import setup_logger

# mp_pose = mp.solutions.pose


# class ImprovedKalmanFilter:
#     """Í≥µÏùò Î¨ºÎ¶¨Ï†Å ÏõÄÏßÅÏûÑÏùÑ Î™®Îç∏ÎßÅÌïòÍ∏∞ ÏúÑÌïú ÏπºÎßå ÌïÑÌÑ∞"""

#     def __init__(self, fps: int = 30):
#         self.dt = 1.0 / fps
#         self.S = np.zeros((6, 1))
#         self.F = np.array(
#             [
#                 [1, self.dt, 0.5 * self.dt**2, 0, 0, 0],
#                 [0, 1, self.dt, 0, 0, 0],
#                 [0, 0, 1, 0, 0, 0],
#                 [0, 0, 0, 1, self.dt, 0.5 * self.dt**2],
#                 [0, 0, 0, 0, 1, self.dt],
#                 [0, 0, 0, 0, 0, 1],
#             ],
#             dtype=float,
#         )
#         self.H = np.array([[1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0]], dtype=float)
#         self.Q = np.eye(6) * config.KF_PROCESS_NOISE
#         self.R = np.eye(2) * config.KF_MEASUREMENT_NOISE
#         self.P = np.eye(6) * 500.0

#         self.frames_without_measurement = 0
#         self.max_prediction_frames = int(fps * 0.7)  # ÏòàÏ∏° ÌóàÏö© ÏãúÍ∞Ñ ÏÜåÌè≠ Ï¶ùÍ∞Ä

#         # ‚ú® Phase 3 Ï∂îÍ∞Ä: Î¨ºÎ¶¨ Î™®Îç∏ Í¥ÄÎ†® Î≥ÄÏàò
#         self.gravity = config.GRAVITY_PIXELS_PER_SECOND_SQUARED
#         self.is_airborne = False
#         self.logger = setup_logger(__name__)

#     def initialize_state(self, initial_pos: tuple):
#         self.S.fill(0)
#         self.S[0, 0] = initial_pos[0]
#         self.S[3, 0] = initial_pos[1]
#         self.P = np.eye(6) * 100.0

#     def predict(self) -> tuple:
#         self.S = self.F @ self.S

#         # ‚ú® Phase 3 Ï∂îÍ∞Ä: Í≥µÏ§ëÏóê Îñ¥ÏùÑ ÎïåÎßå Ï§ëÎ†• Ï†ÅÏö©
#         if self.is_airborne:
#             self.S[5, 0] = self.gravity  # yÏ∂ï Í∞ÄÏÜçÎèÑÏóê Ï§ëÎ†• Ï†ÅÏö©

#         return (self.S[0, 0], self.S[3, 0])

#     def update(self, measurement: Optional[tuple]):
#         if measurement is None:
#             self.frames_without_measurement += 1
#             return
#         z = np.array(measurement).reshape(2, 1)
#         S_k = self.H @ self.P @ self.H.T + self.R
#         K = self.P @ self.H.T @ np.linalg.inv(S_k)
#         self.S = self.S + K @ (z - self.H @ self.S)
#         self.P = (np.eye(6) - K @ self.H) @ self.P
#         self.frames_without_measurement = 0

#     def get_current_state(self) -> dict:
#         return {
#             "position": (self.S[0, 0], self.S[3, 0]),
#             "velocity": (self.S[1, 0], self.S[4, 0]),
#             "confidence": max(
#                 0.0,
#                 1.0 - (self.frames_without_measurement / self.max_prediction_frames),
#             ),
#         }

#     # ‚ú® Phase 3 Ï∂îÍ∞Ä: Ïô∏Î∂Ä Ïã†Ìò∏Ïóê Îî∞Îùº ÌïÑÌÑ∞ ÌååÎùºÎØ∏ÌÑ∞Î•º Î≥ÄÍ≤ΩÌïòÎäî Î©îÏÑúÎìú
#     def set_airborne(self, airborne_status: bool):
#         """Ï§ëÎ†• Ï†ÅÏö© Ïó¨Î∂ÄÎ•º ÏÑ§Ï†ïÌï©ÎãàÎã§."""
#         self.is_airborne = airborne_status
#         if airborne_status:
#             self.logger.info("Kalman Filter: Ï§ëÎ†• Î™®Îç∏ ÌôúÏÑ±Ìôî.")

#     def increase_process_noise_for_kick(self):
#         """ÌÇ• ÏßÅÌõÑÏùò Î∂àÌôïÏã§ÏÑ±ÏùÑ Î∞òÏòÅÌïòÍ∏∞ ÏúÑÌï¥ ÌîÑÎ°úÏÑ∏Ïä§ ÎÖ∏Ïù¥Ï¶àÎ•º ÏùºÏãúÏ†ÅÏúºÎ°ú ÎÜíÏûÖÎãàÎã§."""
#         self.Q *= config.KF_KICK_NOISE_MULTIPLIER
#         self.logger.info(
#             f"Kalman Filter: ÌÇ•ÏúºÎ°ú Ïù∏Ìï¥ ÌîÑÎ°úÏÑ∏Ïä§ ÎÖ∏Ïù¥Ï¶àÎ•º {config.KF_KICK_NOISE_MULTIPLIER}Î∞∞ Ï¶ùÍ∞Ä."
#         )

#     def reset_process_noise(self):
#         """ÌîÑÎ°úÏÑ∏Ïä§ ÎÖ∏Ïù¥Ï¶àÎ•º Í∏∞Î≥∏Í∞íÏúºÎ°ú Î≥µÏõêÌï©ÎãàÎã§."""
#         self.Q = np.eye(6) * config.KF_PROCESS_NOISE


# class BallTracker:
#     """YOLOÏôÄ ÏπºÎßå ÌïÑÌÑ∞Î•º ÏÇ¨Ïö©ÌïòÏó¨ Í≥µÏùÑ ÌÉêÏßÄÌïòÍ≥† Ï∂îÏ†ÅÌïòÎäî Ï¥ùÍ¥Ñ ÌÅ¥ÎûòÏä§"""

#     def __init__(self, fps: int = 30):
#         self.logger = setup_logger(__name__)
#         try:
#             self.yolo_model = YOLO(config.YOLO_MODEL_PATH)
#         except Exception as e:
#             raise RuntimeError(f"YOLO Î™®Îç∏ÏùÑ Î°úÎìúÌï† Ïàò ÏóÜÏäµÎãàÎã§: {e}")

#         self.kf = ImprovedKalmanFilter(fps=fps)
#         self.last_known_ball_info = None
#         self.just_reinitialized = False

#         # ‚ú® Phase 2 Ï∂îÍ∞Ä: Ï∂îÏ†Å ÏÉÅÌÉú Í¥ÄÎ¶¨
#         self.state = "SEARCHING"  # Ï¥àÍ∏∞ ÏÉÅÌÉú: Í≥µÏùÑ Ï∞æÎäî Ï§ë
#         self.occlusion_frames = 0

#     # ball.py

#     # in ball.py -> class BallTracker

#     def _select_best_ball(
#         self,
#         detections: List[Dict],
#         last_pos: tuple,
#         last_radius: Optional[float],
#         pose_landmarks: Optional[mp.solutions.pose.PoseLandmark],
#         frame_shape: tuple,
#     ) -> Optional[dict]:
#         """
#         (ÏÉÅÌÉú Ïù∏ÏßÄ ÏµúÏ¢Ö Î≤ÑÏ†Ñ)
#         'ÌÇ• ÏßÅÌõÑ' ÏÉÅÌÉúÏóê Îî∞Îùº Ï†êÏàò Í∞ÄÏ§ëÏπòÎ•º ÎèôÏ†ÅÏúºÎ°ú Î≥ÄÍ≤ΩÌïòÏó¨ ÏµúÏ†ÅÏùò Í≥µÏùÑ ÏÑ†ÌÉùÌï©ÎãàÎã§.
#         """
#         if not detections:
#             return None

#         best_ball = None
#         min_score = float("inf")

#         # [ÏàòÏ†ï] Ïû¨Ï¥àÍ∏∞Ìôî ÏßÅÌõÑÏù∏ÏßÄ, ÌÇ• ÏßÅÌõÑÏù∏ÏßÄ ÏÉÅÌÉúÎ•º ÌôïÏù∏ÌïòÍ≥†, Í∑∏Ïóê ÎßûÎäî Í∞ÄÏ§ëÏπòÎ•º ÏÑ†ÌÉùÌï©ÎãàÎã§.
#         if self.just_reinitialized:
#             # Ïû¨Ï¥àÍ∏∞Ìôî ÏßÅÌõÑ Ï≤´ ÌîÑÎ†àÏûÑÏóêÎäî ÏòàÏ∏°Ïù¥ Î∂ÄÏ†ïÌôïÌïòÎØÄÎ°ú, ÏòàÏ∏° Ï†êÏàò Í∞ÄÏ§ëÏπòÎ•º 0ÏúºÎ°ú ÏÑ§Ï†ï
#             w_pred = 0.0
#             w_size = config.BALL_SELECTION_WEIGHT_SIZE_POST_KICK
#             w_player = config.BALL_SELECTION_WEIGHT_PLAYER_POST_KICK
#         elif self.state == "POST_IMPACT_TRACKING":
#             # Ïû¨Ï¥àÍ∏∞Ìôî Ïù¥ÌõÑ, Ï†ïÏÉÅÏ†ÅÏù∏ ÌÇ• Ï∂îÏ†Å ÏÉÅÌÉúÏùº ÎïåÏùò Í∞ÄÏ§ëÏπò
#             w_pred = config.BALL_SELECTION_WEIGHT_PREDICTION_POST_KICK
#             w_size = config.BALL_SELECTION_WEIGHT_SIZE_POST_KICK
#             w_player = config.BALL_SELECTION_WEIGHT_PLAYER_POST_KICK
#         else:  # ÌèâÏÉÅÏãú
#             w_pred = config.BALL_SELECTION_WEIGHT_PREDICTION
#             w_size = config.BALL_SELECTION_WEIGHT_SIZE
#             w_player = config.BALL_SELECTION_WEIGHT_PLAYER

#         foot_positions = []
#         if pose_landmarks:
#             left_ankle = pose_landmarks.landmark[
#                 mp.solutions.pose.PoseLandmark.LEFT_ANKLE
#             ]
#             right_ankle = pose_landmarks.landmark[
#                 mp.solutions.pose.PoseLandmark.RIGHT_ANKLE
#             ]
#             if left_ankle.visibility > config.MP_POSE_MIN_DETECTION_CONFIDENCE:
#                 foot_positions.append(
#                     (left_ankle.x * frame_shape[1], left_ankle.y * frame_shape[0])
#                 )
#             if right_ankle.visibility > config.MP_POSE_MIN_DETECTION_CONFIDENCE:
#                 foot_positions.append(
#                     (right_ankle.x * frame_shape[1], right_ankle.y * frame_shape[0])
#                 )

#         for det in detections:
#             dist_from_prediction = np.linalg.norm(
#                 np.array(det["center"]) - np.array(last_pos)
#             )
#             score_pred = min(
#                 dist_from_prediction / config.BALL_SELECT_MAX_PREDICTION_DIST, 1.0
#             )

#             size_diff = (
#                 abs(det["radius"] - last_radius) if last_radius is not None else 0
#             )
#             score_size = min(size_diff / config.BALL_SELECT_MAX_SIZE_DIFF, 1.0)

#             dist_to_foot = float("inf")
#             if foot_positions:
#                 distances_to_feet = [
#                     np.linalg.norm(np.array(det["center"]) - np.array(fp))
#                     for fp in foot_positions
#                 ]
#                 dist_to_foot = (
#                     min(distances_to_feet) if distances_to_feet else float("inf")
#                 )
#             score_foot = min(dist_to_foot / config.BALL_SELECT_MAX_FOOT_DIST, 1.0)

#             # ÏÑ†ÌÉùÎêú Í∞ÄÏ§ëÏπòÎ•º ÏÇ¨Ïö©ÌïòÏó¨ ÏµúÏ¢Ö Ï†êÏàòÎ•º Í≥ÑÏÇ∞Ìï©ÎãàÎã§.
#             final_score = (
#                 score_pred * w_pred + score_size * w_size + score_foot * w_player
#             )

#             if final_score < min_score:
#                 min_score = final_score
#                 best_ball = det

#         return best_ball

#     # ‚ú® Phase 3 Ï∂îÍ∞Ä: analyzer.pyÍ∞Ä Ìò∏Ï∂úÌï† Î©îÏÑúÎìú
#     def notify_impact_detected(self):
#         """
#         analyzerÎ°úÎ∂ÄÌÑ∞ ÏûÑÌå©Ìä∏Í∞Ä Í∞êÏßÄÎêòÏóàÏùåÏùÑ ÌÜµÎ≥¥Î∞õÏïÑ, Ï∂îÏ†Å Î™®ÎìúÎ•º Î≥ÄÍ≤ΩÌï©ÎãàÎã§.
#         """
#         if self.state != "POST_IMPACT_TRACKING":
#             self.state = "POST_IMPACT_TRACKING"
#             self.logger.info("ÏÉÅÌÉú Î≥ÄÍ≤Ω: -> POST_IMPACT_TRACKING")

#             # ÏπºÎßå ÌïÑÌÑ∞Ïùò ÌååÎùºÎØ∏ÌÑ∞Î•º ÎπÑÌñâ Î™®ÎìúÏóê ÎßûÍ≤å Ï°∞Ï†ï
#             self.kf.set_airborne(True)
#             self.kf.increase_process_noise_for_kick()

#     def _get_foot_bbox(self, pose_landmarks, frame_shape) -> Optional[tuple]:
#         if not pose_landmarks:
#             return None
#         l_ankle = pose_landmarks.landmark[mp_pose.PoseLandmark.LEFT_ANKLE]
#         r_ankle = pose_landmarks.landmark[mp_pose.PoseLandmark.RIGHT_ANKLE]
#         if l_ankle.visibility < 0.5 and r_ankle.visibility < 0.5:
#             return None
#         ankle = l_ankle if l_ankle.visibility > r_ankle.visibility else r_ankle
#         x, y = int(ankle.x * frame_shape[1]), int(ankle.y * frame_shape[0])
#         return (x - 40, y - 40, x + 40, y + 40)

#     # üëá Îã§Ïùå ÏóêÎü¨Ïùò ÏõêÏù∏Ïù¥ Îê† ÎªîÌïú ÎàÑÎùΩÎêú Ìï®Ïàò
#     def _is_ball_in_impact_zone(self, ball_center, foot_bbox, margin=50) -> bool:
#         if not ball_center or not foot_bbox:
#             return False
#         fx1, fy1, fx2, fy2 = foot_bbox
#         iz = (fx1 - margin, fy1 - margin, fx2 + margin, fy2 + margin)
#         return iz[0] < ball_center[0] < iz[2] and iz[1] < ball_center[1] < iz[3]

#     def process_frame(
#         self, frame: np.ndarray, pose_landmarks, yolo_results: Optional[List] = None
#     ) -> Dict[str, Any]:
#         best_ball, measurement = None, None

#         if yolo_results is None:
#             yolo_results = self.yolo_model.predict(
#                 frame, conf=config.YOLO_CONF_THRESHOLD, verbose=False
#             )

#         detected_balls = []
#         if yolo_results and yolo_results[0].boxes:
#             for box in yolo_results[0].boxes:

#                 if int(box.cls) == 0:
#                     x1, y1, x2, y2 = box.xyxy[0].cpu().numpy()
#                     detected_balls.append(
#                         {
#                             "center": ((x1 + x2) / 2, (y1 + y2) / 2),
#                             "radius": (x2 - x1) / 2,
#                             "box": [x1, y1, x2, y2],
#                         }
#                     )

#         if self.state == "SEARCHING":
#             if detected_balls:
#                 best_ball = detected_balls[0]
#                 measurement = best_ball["center"]
#                 self.kf.initialize_state(measurement)
#                 self.state = "TRACKING"
#                 self.logger.info(
#                     f"Í≥µ ÌÉêÏßÄ ÏãúÏûë. ÏÉÅÌÉú -> TRACKING. ÏúÑÏπò: {best_ball['center']}"
#                 )
#                 self.last_known_ball_info = best_ball

#         elif self.state in ["TRACKING", "OCCLUDED", "POST_IMPACT_TRACKING"]:
#             predicted_pos = self.kf.predict()
#             last_radius = (
#                 self.last_known_ball_info["radius"]
#                 if self.last_known_ball_info
#                 else None
#             )

#             best_ball = self._select_best_ball(
#                 detected_balls, predicted_pos, last_radius, pose_landmarks, frame.shape
#             )
#             # ÌîåÎûòÍ∑∏Î•º ÏÇ¨Ïö©Ìïú ÌõÑ Î¶¨ÏÖã
#             if self.just_reinitialized:
#                 self.just_reinitialized = False

#             measurement = best_ball["center"] if best_ball else None

#             self.kf.update(measurement)

#             if self.state == "TRACKING" and not best_ball:
#                 foot_bbox = self._get_foot_bbox(pose_landmarks, frame.shape)
#                 if self.last_known_ball_info and self._is_ball_in_impact_zone(
#                     self.last_known_ball_info["center"], foot_bbox
#                 ):
#                     self.state = "OCCLUDED"
#                     self.occlusion_frames = 1
#                     self.logger.warning("ÏûÑÌå©Ìä∏ Ï°¥ÏóêÏÑú Í≥µ ÏÜåÏã§. ÏÉÅÌÉú -> OCCLUDED")

#             elif self.state == "OCCLUDED":
#                 self.occlusion_frames += 1
#                 if best_ball:
#                     self.state = "TRACKING"
#                     self.occlusion_frames = 0
#                     self.logger.info("Í≥µ Ïû¨ÌÉêÏßÄ ÏÑ±Í≥µ. ÏÉÅÌÉú -> TRACKING")
#                 elif self.occlusion_frames > self.kf.max_prediction_frames:
#                     self.state = "SEARCHING"
#                     self.logger.error("Ï∂îÏ†Å ÏôÑÏ†Ñ Ïã§Ìå®. ÏÉÅÌÉú -> SEARCHING")

#         if self.state != "SEARCHING":
#             current_state = self.kf.get_current_state()
#             final_radius = (
#                 best_ball["radius"]
#                 if best_ball
#                 else (
#                     self.last_known_ball_info.get("radius")
#                     if self.last_known_ball_info
#                     else 15
#                 )
#             )
#             final_result = {
#                 "center": current_state["position"],
#                 "radius": final_radius,
#                 "confidence": current_state["confidence"],
#                 "is_predicted": measurement is None,
#                 "box": best_ball["box"] if best_ball else None,
#             }
#             if best_ball:
#                 self.last_known_ball_info = best_ball
#             return final_result
#         else:
#             return {
#                 "center": None,
#                 "radius": None,
#                 "confidence": 0.0,
#                 "is_predicted": True,
#                 "box": None,
#             }

#     def force_reinitialize(self, position: tuple, radius: float):
#         """
#         Ïô∏Î∂ÄÏóêÏÑú Ï£ºÏñ¥ÏßÑ Ï†ïÎ≥¥Î°ú ÏπºÎßå ÌïÑÌÑ∞ÏôÄ Ï∂îÏ†ÅÍ∏∞ ÏÉÅÌÉúÎ•º Í∞ïÏ†úÎ°ú Ïû¨Ï¥àÍ∏∞ÌôîÌï©ÎãàÎã§.
#         'ÏÑ†ÌÉù' Í≥ºÏ†ïÏùÑ ÏÉùÎûµÌïòÍ≥† Ïù¥ Í≥µÏùÑ ÏÉàÎ°úÏö¥ Ï∂îÏ†Å ÎåÄÏÉÅÏúºÎ°ú ÌôïÏ†ïÌï©ÎãàÎã§.
#         """
#         self.logger.info(f"Í∞ïÏ†ú Ïû¨Ï¥àÍ∏∞Ìôî Ïã§Ìñâ. ÌÉÄÍ≤ü ÏúÑÏπò: {position}")

#         # 1. ÏπºÎßå ÌïÑÌÑ∞Ïùò ÏÉÅÌÉúÎ•º ÏÉàÎ°úÏö¥ Í≥µÏùò ÏúÑÏπòÎ°ú Ï¥àÍ∏∞Ìôî
#         self.kf.initialize_state(position)

#         # 2. ÎßàÏßÄÎßâÏúºÎ°ú ÏïåÎ†§ÏßÑ Í≥µ Ï†ïÎ≥¥Î•º ÏÉàÎ°úÏö¥ Í≥µÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏
#         self.last_known_ball_info = {
#             "center": position,
#             "radius": radius,
#             "box": None,  # box Ï†ïÎ≥¥Îäî Ïù¥ ÏãúÏ†êÏóêÏÑúÎäî Ï§ëÏöîÌïòÏßÄ ÏïäÏùå
#         }

#         # 3. ÏÉÅÌÉúÎ•º POST_IMPACT_TRACKING ÏúºÎ°ú Ï¶âÏãú Î≥ÄÍ≤Ω
#         self.notify_impact_detected()
#         self.just_reinitialized = True

# src/ball.py (Îã®ÏàúÌôî Î≤ÑÏ†Ñ)
"""
(Îã®ÏàúÌôî Î≤ÑÏ†Ñ)
YOLOv8 Î™®Îç∏ÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ Í∞Å ÌîÑÎ†àÏûÑÏóêÏÑú Í∞ÄÏû• ÌôïÏã§Ìïú Í≥µÏùÑ ÌÉêÏßÄÌïòÎäî Ïó≠Ìï†Îßå ÏàòÌñâÌï©ÎãàÎã§.
Î≥µÏû°Ìïú ÏπºÎßå ÌïÑÌÑ∞ÎÇò ÏÉÅÌÉú Ï∂îÏ†Å Î°úÏßÅÏùÑ Î™®Îëê Ï†úÍ±∞Ìï©ÎãàÎã§.
"""
import numpy as np
from ultralytics import YOLO
from typing import Dict, Any

# ÎÇ¥Î∂Ä Î™®Îìà ÏûÑÌè¨Ìä∏
from . import config
from .utils import setup_logger


class BallTracker:
    """
    YOLO Î™®Îç∏ÏùÑ Ïù¥Ïö©Ìï¥ ÌîÑÎ†àÏûÑ ÎÇ¥ÏóêÏÑú Í∞ÄÏû• Ïã†Î¢∞ÎèÑ ÎÜíÏùÄ Í≥µ ÌïòÎÇòÎ•º ÌÉêÏßÄÌï©ÎãàÎã§.
    """

    def __init__(self, **kwargs):
        """
        YOLO Î™®Îç∏Îßå Î°úÎìúÌï©ÎãàÎã§. fps Îì± Îã§Î•∏ Ïù∏ÏûêÎäî ÌïÑÏöî ÏóÜÏäµÎãàÎã§.
        """
        self.logger = setup_logger(__name__)
        try:
            self.yolo_model = YOLO(config.YOLO_MODEL_PATH)
            self.logger.info("YOLO Î™®Îç∏ Î°úÎî© ÏÑ±Í≥µ.")
        except Exception as e:
            raise RuntimeError(f"YOLO Î™®Îç∏ÏùÑ Î°úÎìúÌï† Ïàò ÏóÜÏäµÎãàÎã§: {e}")

    def process_frame(self, frame: np.ndarray, *args, **kwargs) -> Dict[str, Any]:
        """
        Ï£ºÏñ¥ÏßÑ ÌîÑÎ†àÏûÑÏóêÏÑú YOLOÎ•º Ïã§ÌñâÌïòÍ≥†, Í∞ÄÏû• Ïã†Î¢∞ÎèÑ(confidence) ÎÜíÏùÄ Í≥µ ÌïòÎÇòÎ•º ÏÑ†ÌÉùÌïòÏó¨
        Í∑∏ Ï†ïÎ≥¥Î•º ÎîïÏÖîÎÑàÎ¶¨ ÌòïÌÉúÎ°ú Î∞òÌôòÌï©ÎãàÎã§.
        """
        # YOLO Î™®Îç∏Î°ú ÏòàÏ∏°ÏùÑ Ïã§ÌñâÌï©ÎãàÎã§. (Í≥µ ÌÅ¥ÎûòÏä§ '0'Îßå ÎåÄÏÉÅ)
        yolo_preds = self.yolo_model.predict(
            frame, conf=config.YOLO_CONF_THRESHOLD, classes=[0], verbose=False
        )

        best_ball_info = None
        max_confidence = -1.0

        # ÏòàÏ∏° Í≤∞Í≥ºÍ∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏Ìï©ÎãàÎã§.
        if yolo_preds and yolo_preds[0].boxes:
            # ÌÉêÏßÄÎêú Î™®Îì† Í≥µ Ï§ëÏóêÏÑú Í∞ÄÏû• Ïã†Î¢∞ÎèÑÍ∞Ä ÎÜíÏùÄ Í≥µÏùÑ Ï∞æÏäµÎãàÎã§.
            for box in yolo_preds[0].boxes:
                if box.conf[0] > max_confidence:
                    max_confidence = float(box.conf[0])
                    x1, y1, x2, y2 = box.xyxy[0].cpu().numpy()
                    best_ball_info = {
                        "center": ((x1 + x2) / 2, (y1 + y2) / 2),
                        "radius": (x2 - x1) / 2,  # Î∞òÏßÄÎ¶ÑÏùÄ ÎÑàÎπÑÎ•º Í∏∞Ï§ÄÏúºÎ°ú Í≥ÑÏÇ∞
                        "box": [x1, y1, x2, y2],
                    }

        if best_ball_info:
            # Í≥µÏùÑ Ï∞æÏïòÏùÑ Í≤ΩÏö∞, Îç∞Ïù¥ÌÑ∞Î•º Î∞òÌôòÌï©ÎãàÎã§.
            # is_predictedÎäî 'False'Î°ú ÏÑ§Ï†ïÌïòÏó¨ Ïã§Ï†ú ÌÉêÏßÄÍ∞íÏûÑÏùÑ Î™ÖÏãúÌï©ÎãàÎã§.
            return {
                "center": best_ball_info["center"],
                "radius": best_ball_info["radius"],
                "confidence": max_confidence,
                "is_predicted": False,
                "box": best_ball_info["box"],
            }
        else:
            # Í≥µÏùÑ Ï∞æÏßÄ Î™ªÌñàÏùÑ Í≤ΩÏö∞, ÎπÑÏñ¥ ÏûàÎäî Îç∞Ïù¥ÌÑ∞Î•º Î∞òÌôòÌï©ÎãàÎã§.
            # is_predictedÎäî 'True'Î°ú ÏÑ§Ï†ïÌïòÏó¨ ÌÉêÏßÄÎêú Í∞íÏù¥ ÏïÑÎãòÏùÑ Î™ÖÏãúÌï©ÎãàÎã§.
            return {
                "center": None,
                "radius": None,
                "confidence": 0.0,
                "is_predicted": True,
                "box": None,
            }
